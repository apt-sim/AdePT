// SPDX-FileCopyrightText: 2022 CERN
// SPDX-License-Identifier: Apache-2.0

#include <AdePT/core/AdePTTransport.h>
#include <AdePT/benchmarking/TestManager.h>
#include <AdePT/benchmarking/TestManagerStore.h>

#include <VecGeom/management/BVHManager.h>
#include "VecGeom/management/GeoManager.h"
#include <VecGeom/gdml/Frontend.h>
#include <VecGeom/base/Stopwatch.h>
#ifdef ADEPT_USE_SURF
#include <VecGeom/surfaces/BrepHelper.h>
#endif

#include "AdePT/copcore/SystemOfUnits.h"

#include <G4HepEmData.hh>
#include <G4HepEmState.hh>
#include <G4HepEmStateInit.hh>
#include <G4HepEmParameters.hh>
#include <G4HepEmMatCutData.hh>

namespace adept_impl {
/// Forward declarations for methods implemented in AdePTTransport.cu
using TrackBuffer = adeptint::TrackBuffer;
template <typename FieldType>
bool InitializeBField(FieldType &);
template <typename FieldType>
void FreeField();
bool InitializeVolAuxArray(adeptint::VolAuxArray &);
void FreeVolAuxArray(adeptint::VolAuxArray &);
G4HepEmState *InitG4HepEm(G4HepEmConfig *hepEmConfig);
GPUstate *InitializeGPU(TrackBuffer &, int, int);
AdeptScoring *InitializeScoringGPU(AdeptScoring *scoring);
void CopySurfaceModelToGPU();
void FreeGPU(GPUstate &, G4HepEmState *);
template <typename IntegrationLayer>
void ShowerGPU(IntegrationLayer &integration, int event, TrackBuffer &buffer, GPUstate &gpuState, AdeptScoring *scoring,
               AdeptScoring *scoring_dev, int debugLevel);

} // namespace adept_impl

template <typename IntegrationLayer>
AdePTTransport<IntegrationLayer>::AdePTTransport(AdePTConfiguration &configuration)
{
  fDebugLevel        = configuration.GetVerbosity();
  fBufferThreshold   = configuration.GetTransportBufferThreshold();
  fMaxBatch          = 2 * configuration.GetTransportBufferThreshold();
  fTrackInAllRegions = configuration.GetTrackInAllRegions();
  fGPURegionNames    = configuration.GetGPURegionNames();
  fCPURegionNames    = configuration.GetCPURegionNames();
  fCUDAStackLimit    = configuration.GetCUDAStackLimit();
  fCUDAHeapLimit     = configuration.GetCUDAHeapLimit();
  fBfieldFile        = configuration.GetCovfieBfieldFile();
  fCapacity          = 1024 * 1024 * configuration.GetMillionsOfTrackSlots() / configuration.GetNumThreads();
  fHitBufferCapacity = 1024 * 1024 * configuration.GetMillionsOfHitSlots() / configuration.GetNumThreads();

  printf("AdePT Allocated track capacity: %d tracks\n", fCapacity);
  printf("AdePT Allocated step buffer capacity: %d tracks\n", fHitBufferCapacity);
}

template <typename IntegrationLayer>
bool AdePTTransport<IntegrationLayer>::InitializeBField()
{
  if (!fBfieldFile.empty()) {
    // Initialize magnetic field data from file
    if (!fMagneticField.InitializeFromFile(fBfieldFile)) {
      return false;
    }

    // Delegate the setup of the global view pointer to adept_impl
    return adept_impl::InitializeBField(fMagneticField);
  }
  return true; // no file provided, but no error encountered, so true is returned
}

template <typename IntegrationLayer>
bool AdePTTransport<IntegrationLayer>::InitializeBField(UniformMagneticField &Bfield)
{
  vecgeom::Vector3D<float> position{
      0.,
      0.,
      0.,
  };
  auto field_value = Bfield.Evaluate(position);
  if (field_value.Mag2() > 0) {
    // Delegate the setup of the global view pointer to adept_impl
    return adept_impl::InitializeBField(Bfield);
  }
  return true; // no B field provided, but no error encountered, so true is returned
}

template <typename IntegrationLayer>
void AdePTTransport<IntegrationLayer>::AddTrack(int pdg, int parent_id, double energy, double vertexEnergy, double x,
                                                double y, double z, double dirx, double diry, double dirz,
                                                double vertexX, double vertexY, double vertexZ, double vertexDirx,
                                                double vertexDiry, double vertexDirz, double globalTime,
                                                double localTime, double properTime, float weight, int /*threadId*/,
                                                unsigned int eventId, unsigned int /*trackIndex*/,
                                                vecgeom::NavigationState &&state,
                                                vecgeom::NavigationState &&originState)
{
  fBuffer.toDevice.emplace_back(pdg, parent_id, energy, vertexEnergy, x, y, z, dirx, diry, dirz, vertexX, vertexY,
                                vertexZ, vertexDirx, vertexDiry, vertexDirz, globalTime, localTime, properTime, weight,
                                std::move(state), std::move(originState));
  if (pdg == 11)
    fBuffer.nelectrons++;
  else if (pdg == -11)
    fBuffer.npositrons++;
  else if (pdg == 22)
    fBuffer.ngammas++;

  if (fBuffer.toDevice.size() >= fBufferThreshold) {
    if (fDebugLevel > 0)
      std::cout << "Reached the threshold of " << fBufferThreshold << " triggering the shower" << std::endl;
    this->Shower(eventId, 0);
  }
}

template <typename IntegrationLayer>
bool AdePTTransport<IntegrationLayer>::InitializeGeometry(const vecgeom::cxx::VPlacedVolume *world)
{
  auto &cudaManager = vecgeom::cxx::CudaManager::Instance();
  if (fCUDAStackLimit > 0) {
    std::cout << "CUDA Device stack limit: " << fCUDAStackLimit << "\n";
    cudaDeviceSetLimit(cudaLimitStackSize, fCUDAStackLimit);
  }
  if (fCUDAHeapLimit > 0) {
    std::cout << "CUDA Device heap limit: " << fCUDAHeapLimit << "\n";
    cudaDeviceSetLimit(cudaLimitMallocHeapSize, fCUDAHeapLimit);
  }
  bool success = true;
#ifdef ADEPT_USE_SURF
#ifdef ADEPT_USE_SURF_SINGLE
  using SurfData   = vgbrep::SurfData<float>;
  using BrepHelper = vgbrep::BrepHelper<float>;
#else
  using SurfData   = vgbrep::SurfData<double>;
  using BrepHelper = vgbrep::BrepHelper<double>;
#endif
  vecgeom::Stopwatch timer;
  timer.Start();
  if (!BrepHelper::Instance().Convert()) return 1;
  BrepHelper::Instance().PrintSurfData();
  std::cout << "== Conversion to surface model done in " << timer.Stop() << " [s]\n";
  // Upload only navigation table to the GPU
  cudaManager.SynchronizeNavigationTable();
  adept_impl::CopySurfaceModelToGPU();
#else
  // Upload solid geometry to GPU.
  cudaManager.LoadGeometry(world);
  auto world_dev = cudaManager.Synchronize();
  success        = world_dev != nullptr;
  // Initialize BVH
  InitBVH();
#endif
  return success;
}

template <typename IntegrationLayer>
bool AdePTTransport<IntegrationLayer>::InitializePhysics(G4HepEmConfig *hepEmConfig)
{
  fg4hepem_state = adept_impl::InitG4HepEm(hepEmConfig);
  return true;
}

template <typename IntegrationLayer>
void AdePTTransport<IntegrationLayer>::Initialize(G4HepEmConfig *hepEmConfig, bool common_data)
{
  if (fInit) return;
  if (fMaxBatch <= 0)
    throw std::runtime_error("AdePTTransport<IntegrationLayer>::Initialize: Maximum batch size not set.");

  fNumVolumes = vecgeom::GeoManager::Instance().GetRegisteredVolumesCount();

  if (fNumVolumes == 0)
    throw std::runtime_error("AdePTTransport<IntegrationLayer>::Initialize: Number of geometry volumes is zero.");

  if (common_data) {
    std::cout << "=== AdePTTransport: initializing geometry and physics\n";
    // Initialize geometry on device
    if (!vecgeom::GeoManager::Instance().IsClosed())
      throw std::runtime_error("AdePTTransport<IntegrationLayer>::Initialize: VecGeom geometry not closed.");

    const vecgeom::cxx::VPlacedVolume *world = vecgeom::GeoManager::Instance().GetWorld();
    if (!InitializeGeometry(world))
      throw std::runtime_error("AdePTTransport<IntegrationLayer>::Initialize: Cannot initialize geometry on GPU");

    // Initialize G4HepEm
    if (!InitializePhysics(hepEmConfig))
      throw std::runtime_error("AdePTTransport<IntegrationLayer>::Initialize cannot initialize physics on GPU");

#ifdef ADEPT_USE_EXT_BFIELD
    // Try to initialize field from file
    if (!InitializeBField()) {
      throw std::runtime_error(
          "AdePTTransport<IntegrationLayer>::Initialize cannot initialize GeneralMagneticField on GPU");
    }
#else
    auto field_values                            = fIntegrationLayer.GetUniformField(); // Get the field value
    std::unique_ptr<UniformMagneticField> Bfield = std::make_unique<UniformMagneticField>(field_values);
    if (!InitializeBField(*Bfield))
      throw std::runtime_error("AdePTTransport<IntegrationLayer>::Initialize cannot initialize field on GPU");
#endif

    // Do the material-cut couple index mapping once
    // as well as set flags for sensitive volumes and region

    // Check VecGeom geometry matches Geant4. Initialize auxiliary per-LV data. Initialize scoring map.
    fIntegrationLayer.CheckGeometry(fg4hepem_state);
    adeptint::VolAuxData *auxData =
        new adeptint::VolAuxData[vecgeom::GeoManager::Instance().GetRegisteredVolumesCount()];
    fIntegrationLayer.InitVolAuxData(auxData, fg4hepem_state, fTrackInAllRegions, fGPURegionNames);

    // Initialize volume auxiliary data on device
    auto &volAuxArray       = VolAuxArray::GetInstance();
    volAuxArray.fNumVolumes = fNumVolumes;
    volAuxArray.fAuxData    = auxData;
    adept_impl::InitializeVolAuxArray(volAuxArray);

    // Print some settings
    std::cout << "=== AdePTTransport: buffering " << fBufferThreshold << " particles for transport on the GPU"
              << std::endl;
    std::cout << "=== AdePTTransport: maximum number of GPU track slots per thread: " << fCapacity << std::endl;
    return;
  }

  std::cout << "=== AdePTTransport: initializing transport engine for thread: " << fIntegrationLayer.GetThreadID()
            << std::endl;

  // Initialize user scoring data on Host
  fScoring = new AdeptScoring(fHitBufferCapacity);

  // Initialize the transport engine for the current thread
  fGPUstate    = adept_impl::InitializeGPU(fBuffer, fCapacity, fMaxBatch);
  fScoring_dev = adept_impl::InitializeScoringGPU(fScoring);

  fInit = true;
}

template <typename IntegrationLayer>
void AdePTTransport<IntegrationLayer>::InitBVH()
{
  vecgeom::BVHManager::Init();
#ifndef ADEPT_USE_SURF
  vecgeom::BVHManager::DeviceInit();
#endif
}

template <typename IntegrationLayer>
void AdePTTransport<IntegrationLayer>::Cleanup()
{
  if (!fInit) return;
  adept_impl::FreeGPU(*fGPUstate, fg4hepem_state);
  fg4hepem_state = nullptr;
  adept_impl::FreeVolAuxArray(VolAuxArray::GetInstance());
  adept_scoring::FreeGPU(fScoring, fScoring_dev);
  delete[] fBuffer.fromDeviceBuff;
}

template <typename IntegrationLayer>
void AdePTTransport<IntegrationLayer>::Shower(int event, int /*threadId*/)
{
  int tid = fIntegrationLayer.GetThreadID();
  if (fBuffer.toDevice.size() == 0) {
    if (fDebugLevel > 0)
      std::cout << "[" << tid << "] AdePTTransport<IntegrationLayer>::Shower: No more particles in buffer. Exiting.\n";
    return;
  }

  if (event != fBuffer.eventId) {
    fBuffer.eventId    = event;
    fBuffer.startTrack = 0;
  } else {
    fBuffer.startTrack += fBuffer.toDevice.size();
  }

  int itr   = 0;
  int nelec = 0, nposi = 0, ngamma = 0;
  if (fDebugLevel > 0) {
    std::cout << "[" << tid << "] toDevice: " << fBuffer.nelectrons << " elec, " << fBuffer.npositrons << " posi, "
              << fBuffer.ngammas << " gamma\n";
  }
  if (fDebugLevel > 1) {
    for (auto &track : fBuffer.toDevice) {
      std::cout << "[" << tid << "] toDevice[ " << itr++ << "]: pdg " << track.pdg << " kinetic energy " << track.eKin
                << " position " << track.position[0] << " " << track.position[1] << " " << track.position[2]
                << " direction " << track.direction[0] << " " << track.direction[1] << " " << track.direction[2]
                << " global time, local time, proper time: "
                << "(" << track.globalTime << ", " << track.localTime << ", " << track.properTime << ")" << std::endl;
    }
  }

  if (fDebugLevel > 0) {
    std::cout << std::dec << std::endl
              << "GPU transporting event " << event << " for CPU thread " << fIntegrationLayer.GetThreadID() << ": "
              << std::flush;
  }
  adept_impl::ShowerGPU(fIntegrationLayer, event, fBuffer, *fGPUstate, fScoring, fScoring_dev, fDebugLevel);

  for (auto const &track : fBuffer.fromDevice) {
    if (track.pdg == 11)
      nelec++;
    else if (track.pdg == -11)
      nposi++;
    else if (track.pdg == 22)
      ngamma++;
  }
  if (fDebugLevel > 0) {
    std::cout << "[" << tid << "] fromDevice: " << nelec << " elec, " << nposi << " posi, " << ngamma << " gamma\n";
  }

  fIntegrationLayer.ReturnTracks(fBuffer.fromDevice.begin(), fBuffer.fromDevice.end(), fDebugLevel);

  fBuffer.Clear();
}
